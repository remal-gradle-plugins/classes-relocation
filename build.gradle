import static java.util.stream.Collectors.toList

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

buildscript {
    String rootGroupId = project.ext.rootGroupId = "name.remal.gradle-plugins.${rootProject.name}"
    String rootArtifactId = project.ext.rootArtifactId = rootProject.name
    String rootSnapshotVersion = project.ext.rootSnapshotVersion = '2-SNAPSHOT'
    dependencies {
        //classpath("$rootGroupId:$rootArtifactId:$rootSnapshotVersion") { version { strictly(rootSnapshotVersion) } }
        classpath 'name.remal.gradle-plugins.toolkit:build-logic:0.70.3'
    }
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

allprojects {
    group = project.rootGroupId
    version = project.rootSnapshotVersion
}

apply plugin: 'name.remal.toolkit.build-logic'

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

apply plugin: 'java-gradle-plugin'

gradlePlugin {
    plugins {
        'name.remal.classes-relocation' {
            id = 'name.remal.classes-relocation'
            implementationClass = 'name.remal.gradle_plugins.classes_relocation.ClassesRelocationPlugin'
            displayName = 'Classes relocation'
            description = property('repository-description')
        }
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

Project relocatorProject = project(':relocator')
project.fatJarWith(relocatorProject)

project.pluginManager.withPlugin('java') {
    relocatorProject.pluginManager.withPlugin('java') {
        ; ['classesRelocation', 'runtimeOnly', 'implementation', 'api'].forEach { confName ->
            project.configurations.matching { it.name == confName }.all { Configuration conf ->
                relocatorProject.configurations.matching { it.name == confName }.all { Configuration relocatorConf ->
                    relocatorConf.dependencies.all { Dependency dep ->
                        conf.dependencies.add(dep.copy())
                    }
                }
            }
        }
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

SourceSet functionalTestSourceSet = testSourceSets.getByName('functionalTest')

dependencies {
    functionalTestImplementation 'name.remal.gradle-plugins.test-source-sets:test-source-sets:4.1.10'
}

Map<String, String> functionalTestRelocationNotations = [
    'guava': 'com.google.guava:guava',
    'test-source-sets': 'name.remal.gradle-plugins.test-source-sets:test-source-sets',

    'junit-jupiter-api': 'org.junit.jupiter:junit-jupiter-api',
    'junit-jupiter-engine': 'org.junit.jupiter:junit-jupiter-engine',
    'junit-platform-launcher': 'org.junit.platform:junit-platform-launcher',
]

tasks.named(functionalTestSourceSet.name, Test) {
    inputs.property('functionalTestRelocationNotations', functionalTestRelocationNotations)

    onlyIf {
        functionalTestRelocationNotations.forEach { library, notation ->
            Closure<List<ResolvedDependency>> getResolvedDependenciesFrom = { String confName ->
                Configuration conf = configurations[confName]
                return conf.resolvedConfiguration
                    .firstLevelModuleDependencies
                    .findAll { "${it.moduleGroup}:${it.moduleName}" == notation }
                    .toList()
            }

            List<ResolvedDependency> resolvedDeps = getResolvedDependenciesFrom(functionalTestSourceSet.compileClasspathConfigurationName)
            if (resolvedDeps.isEmpty()) {
                resolvedDeps = getResolvedDependenciesFrom(functionalTestSourceSet.runtimeClasspathConfigurationName)
            }
            if (resolvedDeps.isEmpty()) {
                throw new GradleException("Resolved dependencies with notation `$notation` can't be found in `${functionalTestSourceSet.name}` dependencies")
            }
            Collection<File> files = resolvedDeps.stream()
                .flatMap { dep -> dep.allModuleArtifacts.stream() }
                .map { artifact -> artifact.file }
                .distinct()
                .collect(toList())
            systemProperty("$library-classpath", files.join(File.pathSeparator))
        }

        return true
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

tasks.withType(JacocoReportBase).configureEach { JacocoReportBase task ->
    task.onlyIf {
        logger.warn('Remove included files filtering when a new version of toolkit is released')
        Closure filterOutIncludedFiles = { ConfigurableFileCollection fileCollection ->
            fileCollection.setFrom(
                fileCollection.files
                    .findAll { !relocatorProject.sourceSets.main.allSource.srcDirs.contains(it) }
                    .findAll { !relocatorProject.sourceSets.main.output.contains(it) }
                    .findAll { relocatorProject.tasks.jar.archiveFile.get().asFile != it }
            )
        }
        filterOutIncludedFiles(task.sourceDirectories)
        filterOutIncludedFiles(task.classDirectories)
        filterOutIncludedFiles(task.additionalClassDirs)
        return true
    }
}
